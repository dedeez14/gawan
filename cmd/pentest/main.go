package main

import (
	"bufio"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"
)

// PentestResult represents a single test result
type PentestResult struct {
	TestName    string    `json:"test_name"`
	Severity    string    `json:"severity"`
	Status      string    `json:"status"`
	Description string    `json:"description"`
	Evidence    string    `json:"evidence"`
	Remediation string    `json:"remediation"`
	Timestamp   time.Time `json:"timestamp"`
}

// PentestReport represents the complete penetration test report
type PentestReport struct {
	StartTime   time.Time       `json:"start_time"`
	EndTime     time.Time       `json:"end_time"`
	Target      string          `json:"target"`
	Results     []PentestResult `json:"results"`
	Summary     TestSummary     `json:"summary"`
}

// TestSummary provides an overview of test results
type TestSummary struct {
	TotalTests    int `json:"total_tests"`
	CriticalIssues int `json:"critical_issues"`
	HighIssues     int `json:"high_issues"`
	MediumIssues   int `json:"medium_issues"`
	LowIssues      int `json:"low_issues"`
	InfoIssues     int `json:"info_issues"`
}

// PentestSuite contains all penetration testing functionality
type PentestSuite struct {
	target  string
	results []PentestResult
	mu      sync.Mutex
}

// NewPentestSuite creates a new penetration testing suite
func NewPentestSuite(target string) *PentestSuite {
	return &PentestSuite{
		target: target,
		results: make([]PentestResult, 0),
	}
}

// AddResult adds a test result to the suite
func (ps *PentestSuite) AddResult(result PentestResult) {
	ps.mu.Lock()
	defer ps.mu.Unlock()
	result.Timestamp = time.Now()
	ps.results = append(ps.results, result)
}

// 1. Port Scanning and Service Detection
func (ps *PentestSuite) PortScan() {
	fmt.Println("[+] Starting Port Scan...")
	
	commonPorts := []int{21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 8080, 8443, 3000, 5000, 8000}
	
	for _, port := range commonPorts {
		address := fmt.Sprintf("%s:%d", ps.target, port)
		conn, err := net.DialTimeout("tcp", address, 2*time.Second)
		
		if err == nil {
			conn.Close()
			ps.AddResult(PentestResult{
				TestName:    "Port Scan",
				Severity:    "INFO",
				Status:      "OPEN",
				Description: fmt.Sprintf("Port %d is open", port),
				Evidence:    fmt.Sprintf("TCP connection successful to %s", address),
				Remediation: "Review if this service is necessary and properly secured",
			})
			fmt.Printf("[+] Port %d: OPEN\n", port)
		} else {
			fmt.Printf("[-] Port %d: CLOSED\n", port)
		}
	}
}

// 2. Web Application Vulnerability Testing
func (ps *PentestSuite) WebVulnScan() {
	fmt.Println("\n[+] Starting Web Application Vulnerability Scan...")
	
	// Test for common web vulnerabilities
	ps.testSQLInjection()
	ps.testXSS()
	ps.testCSRF()
	ps.testDirectoryTraversal()
	ps.testCommandInjection()
	ps.testHTTPHeaders()
}

// SQL Injection Testing
func (ps *PentestSuite) testSQLInjection() {
	fmt.Println("[+] Testing SQL Injection...")
	
	sqlPayloads := []string{
		"' OR '1'='1",
		"' OR 1=1--",
		"' UNION SELECT NULL--",
		"'; DROP TABLE users;--",
		"1' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
	}
	
	testURLs := []string{
		fmt.Sprintf("http://%s/login", ps.target),
		fmt.Sprintf("http://%s/search", ps.target),
		fmt.Sprintf("http://%s/api/users", ps.target),
	}
	
	for _, url := range testURLs {
		for _, payload := range sqlPayloads {
			resp, err := http.PostForm(url, map[string][]string{
				"username": {payload},
				"password": {payload},
				"q":        {payload},
			})
			
			if err != nil {
				continue
			}
			
			body, _ := io.ReadAll(resp.Body)
			resp.Body.Close()
			
			// Check for SQL error messages
			bodyStr := strings.ToLower(string(body))
			sqlErrors := []string{"sql syntax", "mysql_fetch", "ora-", "microsoft ole db", "sqlite_"}
			
			for _, sqlError := range sqlErrors {
				if strings.Contains(bodyStr, sqlError) {
					ps.AddResult(PentestResult{
						TestName:    "SQL Injection",
						Severity:    "CRITICAL",
						Status:      "VULNERABLE",
						Description: "Potential SQL injection vulnerability detected",
						Evidence:    fmt.Sprintf("URL: %s, Payload: %s, Error: %s", url, payload, sqlError),
						Remediation: "Use parameterized queries and input validation",
					})
					return
				}
			}
		}
	}
	
	ps.AddResult(PentestResult{
		TestName:    "SQL Injection",
		Severity:    "INFO",
		Status:      "SECURE",
		Description: "No SQL injection vulnerabilities detected",
		Evidence:    "Tested common SQL injection payloads",
		Remediation: "Continue monitoring and use secure coding practices",
	})
}

// XSS Testing
func (ps *PentestSuite) testXSS() {
	fmt.Println("[+] Testing Cross-Site Scripting (XSS)...")
	
	xssPayloads := []string{
		"<script>alert('XSS')</script>",
		"<img src=x onerror=alert('XSS')>",
		"javascript:alert('XSS')",
		"<svg onload=alert('XSS')>",
	}
	
	testURL := fmt.Sprintf("http://%s/search", ps.target)
	
	for _, payload := range xssPayloads {
		resp, err := http.Get(fmt.Sprintf("%s?q=%s", testURL, payload))
		if err != nil {
			continue
		}
		
		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()
		
		if strings.Contains(string(body), payload) {
			ps.AddResult(PentestResult{
				TestName:    "Cross-Site Scripting (XSS)",
				Severity:    "HIGH",
				Status:      "VULNERABLE",
				Description: "Reflected XSS vulnerability detected",
				Evidence:    fmt.Sprintf("Payload reflected: %s", payload),
				Remediation: "Implement proper input sanitization and output encoding",
			})
			return
		}
	}
	
	ps.AddResult(PentestResult{
		TestName:    "Cross-Site Scripting (XSS)",
		Severity:    "INFO",
		Status:      "SECURE",
		Description: "No XSS vulnerabilities detected",
		Evidence:    "Tested common XSS payloads",
		Remediation: "Continue using proper input validation",
	})
}

// CSRF Testing
func (ps *PentestSuite) testCSRF() {
	fmt.Println("[+] Testing Cross-Site Request Forgery (CSRF)...")
	
	testURL := fmt.Sprintf("http://%s/api/users", ps.target)
	resp, err := http.PostForm(testURL, map[string][]string{
		"action": {"delete"},
		"id":     {"1"},
	})
	
	if err == nil {
		if resp.StatusCode == 200 {
			ps.AddResult(PentestResult{
				TestName:    "Cross-Site Request Forgery (CSRF)",
				Severity:    "MEDIUM",
				Status:      "VULNERABLE",
				Description: "Potential CSRF vulnerability - no token validation",
				Evidence:    "POST request accepted without CSRF token",
				Remediation: "Implement CSRF tokens for state-changing operations",
			})
		} else {
			ps.AddResult(PentestResult{
				TestName:    "Cross-Site Request Forgery (CSRF)",
				Severity:    "INFO",
				Status:      "SECURE",
				Description: "CSRF protection appears to be in place",
				Evidence:    fmt.Sprintf("Request rejected with status: %d", resp.StatusCode),
				Remediation: "Continue using CSRF protection",
			})
		}
		resp.Body.Close()
	}
}

// Directory Traversal Testing
func (ps *PentestSuite) testDirectoryTraversal() {
	fmt.Println("[+] Testing Directory Traversal...")
	
	traversalPayloads := []string{
		"../../../etc/passwd",
		"..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
		"....//....//....//etc/passwd",
	}
	
	for _, payload := range traversalPayloads {
		testURL := fmt.Sprintf("http://%s/file?path=%s", ps.target, payload)
		resp, err := http.Get(testURL)
		
		if err != nil {
			continue
		}
		
		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()
		
		bodyStr := string(body)
		if strings.Contains(bodyStr, "root:") || strings.Contains(bodyStr, "localhost") {
			ps.AddResult(PentestResult{
				TestName:    "Directory Traversal",
				Severity:    "HIGH",
				Status:      "VULNERABLE",
				Description: "Directory traversal vulnerability detected",
				Evidence:    fmt.Sprintf("Payload: %s, Response contains system files", payload),
				Remediation: "Implement proper path validation and sanitization",
			})
			return
		}
	}
	
	ps.AddResult(PentestResult{
		TestName:    "Directory Traversal",
		Severity:    "INFO",
		Status:      "SECURE",
		Description: "No directory traversal vulnerabilities detected",
		Evidence:    "Tested common traversal payloads",
		Remediation: "Continue using proper path validation",
	})
}

// Command Injection Testing
func (ps *PentestSuite) testCommandInjection() {
	fmt.Println("[+] Testing Command Injection...")
	
	cmdPayloads := []string{
		"; ls -la",
		"| whoami",
		"& dir",
		"`id`",
	}
	
	for _, payload := range cmdPayloads {
		testURL := fmt.Sprintf("http://%s/ping", ps.target)
		resp, err := http.PostForm(testURL, map[string][]string{
			"host": {"127.0.0.1" + payload},
		})
		
		if err != nil {
			continue
		}
		
		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()
		
		bodyStr := strings.ToLower(string(body))
		if strings.Contains(bodyStr, "uid=") || strings.Contains(bodyStr, "volume") {
			ps.AddResult(PentestResult{
				TestName:    "Command Injection",
				Severity:    "CRITICAL",
				Status:      "VULNERABLE",
				Description: "Command injection vulnerability detected",
				Evidence:    fmt.Sprintf("Payload: %s, Command output detected", payload),
				Remediation: "Use parameterized commands and input validation",
			})
			return
		}
	}
	
	ps.AddResult(PentestResult{
		TestName:    "Command Injection",
		Severity:    "INFO",
		Status:      "SECURE",
		Description: "No command injection vulnerabilities detected",
		Evidence:    "Tested common command injection payloads",
		Remediation: "Continue using secure command execution practices",
	})
}

// HTTP Security Headers Testing
func (ps *PentestSuite) testHTTPHeaders() {
	fmt.Println("[+] Testing HTTP Security Headers...")
	
	testURL := fmt.Sprintf("http://%s/", ps.target)
	resp, err := http.Get(testURL)
	
	if err != nil {
		ps.AddResult(PentestResult{
			TestName:    "HTTP Headers",
			Severity:    "HIGH",
			Status:      "ERROR",
			Description: "Unable to connect to target",
			Evidence:    err.Error(),
			Remediation: "Ensure the target is accessible",
		})
		return
	}
	defer resp.Body.Close()
	
	// Check for security headers
	securityHeaders := map[string]string{
		"X-Content-Type-Options": "nosniff",
		"X-Frame-Options":        "DENY",
		"X-XSS-Protection":       "1",
		"Strict-Transport-Security": "max-age",
		"Content-Security-Policy": "default-src",
	}
	
	for header, expectedValue := range securityHeaders {
		headerValue := resp.Header.Get(header)
		if headerValue == "" {
			ps.AddResult(PentestResult{
				TestName:    "HTTP Security Headers",
				Severity:    "MEDIUM",
				Status:      "MISSING",
				Description: fmt.Sprintf("Missing security header: %s", header),
				Evidence:    "Header not present in response",
				Remediation: fmt.Sprintf("Add %s header with appropriate value", header),
			})
		} else if !strings.Contains(strings.ToLower(headerValue), strings.ToLower(expectedValue)) {
			ps.AddResult(PentestResult{
				TestName:    "HTTP Security Headers",
				Severity:    "LOW",
				Status:      "WEAK",
				Description: fmt.Sprintf("Weak security header: %s", header),
				Evidence:    fmt.Sprintf("Current value: %s", headerValue),
				Remediation: fmt.Sprintf("Strengthen %s header configuration", header),
			})
		} else {
			ps.AddResult(PentestResult{
				TestName:    "HTTP Security Headers",
				Severity:    "INFO",
				Status:      "SECURE",
				Description: fmt.Sprintf("Security header present: %s", header),
				Evidence:    fmt.Sprintf("Value: %s", headerValue),
				Remediation: "Continue monitoring header configuration",
			})
		}
	}
}

// 3. Security Configuration Analysis
func (ps *PentestSuite) SecurityConfigAnalysis() {
	fmt.Println("\n[+] Starting Security Configuration Analysis...")
	
	ps.testTLSConfiguration()
	ps.testServerInformation()
	ps.testDirectoryListing()
}

// TLS Configuration Testing
func (ps *PentestSuite) testTLSConfiguration() {
	fmt.Println("[+] Testing TLS Configuration...")
	
	testURL := fmt.Sprintf("https://%s", ps.target)
	
	// Test with insecure TLS config
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: true,
			MinVersion:         tls.VersionTLS10,
		},
	}
	client := &http.Client{Transport: tr, Timeout: 10 * time.Second}
	
	resp, err := client.Get(testURL)
	if err != nil {
		ps.AddResult(PentestResult{
			TestName:    "TLS Configuration",
			Severity:    "INFO",
			Status:      "NO_TLS",
			Description: "HTTPS not available or configured",
			Evidence:    err.Error(),
			Remediation: "Implement HTTPS with proper TLS configuration",
		})
		return
	}
	defer resp.Body.Close()
	
	// Check TLS version
	if resp.TLS != nil {
		tlsVersion := ""
		switch resp.TLS.Version {
		case tls.VersionTLS10:
			tlsVersion = "TLS 1.0"
			ps.AddResult(PentestResult{
				TestName:    "TLS Configuration",
				Severity:    "HIGH",
				Status:      "WEAK",
				Description: "Weak TLS version in use",
				Evidence:    "TLS 1.0 is deprecated and insecure",
				Remediation: "Upgrade to TLS 1.2 or higher",
			})
		case tls.VersionTLS11:
			tlsVersion = "TLS 1.1"
			ps.AddResult(PentestResult{
				TestName:    "TLS Configuration",
				Severity:    "MEDIUM",
				Status:      "WEAK",
				Description: "Outdated TLS version in use",
				Evidence:    "TLS 1.1 is deprecated",
				Remediation: "Upgrade to TLS 1.2 or higher",
			})
		case tls.VersionTLS12:
			tlsVersion = "TLS 1.2"
			ps.AddResult(PentestResult{
				TestName:    "TLS Configuration",
				Severity:    "INFO",
				Status:      "SECURE",
				Description: "Secure TLS version in use",
				Evidence:    "TLS 1.2 is acceptable",
				Remediation: "Consider upgrading to TLS 1.3 for better security",
			})
		case tls.VersionTLS13:
			tlsVersion = "TLS 1.3"
			ps.AddResult(PentestResult{
				TestName:    "TLS Configuration",
				Severity:    "INFO",
				Status:      "SECURE",
				Description: "Modern TLS version in use",
				Evidence:    "TLS 1.3 provides excellent security",
				Remediation: "Continue using TLS 1.3",
			})
		}
		
		fmt.Printf("[+] TLS Version: %s\n", tlsVersion)
	}
}

// Server Information Disclosure Testing
func (ps *PentestSuite) testServerInformation() {
	fmt.Println("[+] Testing Server Information Disclosure...")
	
	testURL := fmt.Sprintf("http://%s/", ps.target)
	resp, err := http.Get(testURL)
	
	if err != nil {
		return
	}
	defer resp.Body.Close()
	
	// Check for server header
	serverHeader := resp.Header.Get("Server")
	if serverHeader != "" {
		ps.AddResult(PentestResult{
			TestName:    "Information Disclosure",
			Severity:    "LOW",
			Status:      "INFO_LEAK",
			Description: "Server information disclosed",
			Evidence:    fmt.Sprintf("Server header: %s", serverHeader),
			Remediation: "Remove or obfuscate server version information",
		})
	}
	
	// Check for X-Powered-By header
	poweredBy := resp.Header.Get("X-Powered-By")
	if poweredBy != "" {
		ps.AddResult(PentestResult{
			TestName:    "Information Disclosure",
			Severity:    "LOW",
			Status:      "INFO_LEAK",
			Description: "Technology stack information disclosed",
			Evidence:    fmt.Sprintf("X-Powered-By header: %s", poweredBy),
			Remediation: "Remove X-Powered-By header",
		})
	}
}

// Directory Listing Testing
func (ps *PentestSuite) testDirectoryListing() {
	fmt.Println("[+] Testing Directory Listing...")
	
	commonDirs := []string{"/admin", "/backup", "/config", "/logs", "/temp", "/uploads"}
	
	for _, dir := range commonDirs {
		testURL := fmt.Sprintf("http://%s%s/", ps.target, dir)
		resp, err := http.Get(testURL)
		
		if err != nil {
			continue
		}
		
		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()
		
		bodyStr := strings.ToLower(string(body))
		if strings.Contains(bodyStr, "index of") || strings.Contains(bodyStr, "directory listing") {
			ps.AddResult(PentestResult{
				TestName:    "Directory Listing",
				Severity:    "MEDIUM",
				Status:      "VULNERABLE",
				Description: "Directory listing enabled",
				Evidence:    fmt.Sprintf("Directory listing found at: %s", testURL),
				Remediation: "Disable directory listing and add index files",
			})
		}
	}
}

// 4. Authentication and Authorization Testing
func (ps *PentestSuite) AuthenticationTesting() {
	fmt.Println("\n[+] Starting Authentication and Authorization Testing...")
	
	ps.testWeakCredentials()
	ps.testBruteForceProtection()
	ps.testSessionManagement()
	ps.testAccessControl()
}

// Weak Credentials Testing
func (ps *PentestSuite) testWeakCredentials() {
	fmt.Println("[+] Testing Weak Credentials...")
	
	commonCreds := [][]string{
		{"admin", "admin"},
		{"admin", "password"},
		{"admin", "123456"},
		{"root", "root"},
		{"user", "user"},
		{"guest", "guest"},
		{"test", "test"},
		{"demo", "demo"},
	}
	
	loginURL := fmt.Sprintf("http://%s/login", ps.target)
	
	for _, cred := range commonCreds {
		username, password := cred[0], cred[1]
		resp, err := http.PostForm(loginURL, map[string][]string{
			"username": {username},
			"password": {password},
		})
		
		if err != nil {
			continue
		}
		
		// Check for successful login indicators
		if resp.StatusCode == 200 || resp.StatusCode == 302 {
			body, _ := io.ReadAll(resp.Body)
			bodyStr := strings.ToLower(string(body))
			
			if !strings.Contains(bodyStr, "invalid") && !strings.Contains(bodyStr, "error") {
				ps.AddResult(PentestResult{
					TestName:    "Weak Credentials",
					Severity:    "CRITICAL",
					Status:      "VULNERABLE",
					Description: "Weak default credentials found",
					Evidence:    fmt.Sprintf("Username: %s, Password: %s", username, password),
					Remediation: "Change default credentials and enforce strong password policy",
				})
			}
		}
		resp.Body.Close()
	}
}

// Brute Force Protection Testing
func (ps *PentestSuite) testBruteForceProtection() {
	fmt.Println("[+] Testing Brute Force Protection...")
	
	loginURL := fmt.Sprintf("http://%s/login", ps.target)
	attempts := 10
	
	for i := 0; i < attempts; i++ {
		resp, err := http.PostForm(loginURL, map[string][]string{
			"username": {"testuser"},
			"password": {fmt.Sprintf("wrongpass%d", i)},
		})
		
		if err != nil {
			continue
		}
		
		if resp.StatusCode == 429 || resp.StatusCode == 423 {
			ps.AddResult(PentestResult{
				TestName:    "Brute Force Protection",
				Severity:    "INFO",
				Status:      "SECURE",
				Description: "Brute force protection is active",
				Evidence:    fmt.Sprintf("Rate limiting triggered after %d attempts", i+1),
				Remediation: "Continue monitoring brute force attempts",
			})
			resp.Body.Close()
			return
		}
		resp.Body.Close()
		time.Sleep(100 * time.Millisecond)
	}
	
	ps.AddResult(PentestResult{
		TestName:    "Brute Force Protection",
		Severity:    "HIGH",
		Status:      "VULNERABLE",
		Description: "No brute force protection detected",
		Evidence:    fmt.Sprintf("Completed %d login attempts without rate limiting", attempts),
		Remediation: "Implement rate limiting and account lockout mechanisms",
	})
}

// Session Management Testing
func (ps *PentestSuite) testSessionManagement() {
	fmt.Println("[+] Testing Session Management...")
	
	testURL := fmt.Sprintf("http://%s/", ps.target)
	resp, err := http.Get(testURL)
	
	if err != nil {
		return
	}
	defer resp.Body.Close()
	
	// Check for session cookies
	for _, cookie := range resp.Cookies() {
		if strings.Contains(strings.ToLower(cookie.Name), "session") || 
		   strings.Contains(strings.ToLower(cookie.Name), "auth") {
			
			// Check HttpOnly flag
			if !cookie.HttpOnly {
				ps.AddResult(PentestResult{
					TestName:    "Session Management",
					Severity:    "MEDIUM",
					Status:      "VULNERABLE",
					Description: "Session cookie missing HttpOnly flag",
					Evidence:    fmt.Sprintf("Cookie: %s", cookie.Name),
					Remediation: "Set HttpOnly flag on session cookies",
				})
			}
			
			// Check Secure flag
			if !cookie.Secure {
				ps.AddResult(PentestResult{
					TestName:    "Session Management",
					Severity:    "MEDIUM",
					Status:      "VULNERABLE",
					Description: "Session cookie missing Secure flag",
					Evidence:    fmt.Sprintf("Cookie: %s", cookie.Name),
					Remediation: "Set Secure flag on session cookies for HTTPS",
				})
			}
			
			// Check SameSite attribute
			if cookie.SameSite == http.SameSiteDefaultMode {
				ps.AddResult(PentestResult{
					TestName:    "Session Management",
					Severity:    "LOW",
					Status:      "WEAK",
					Description: "Session cookie missing SameSite attribute",
					Evidence:    fmt.Sprintf("Cookie: %s", cookie.Name),
					Remediation: "Set SameSite attribute on session cookies",
				})
			}
		}
	}
}

// Access Control Testing
func (ps *PentestSuite) testAccessControl() {
	fmt.Println("[+] Testing Access Control...")
	
	adminPaths := []string{"/admin", "/admin/users", "/admin/config", "/api/admin"}
	
	for _, path := range adminPaths {
		testURL := fmt.Sprintf("http://%s%s", ps.target, path)
		resp, err := http.Get(testURL)
		
		if err != nil {
			continue
		}
		
		if resp.StatusCode == 200 {
			body, _ := io.ReadAll(resp.Body)
			bodyStr := strings.ToLower(string(body))
			
			if !strings.Contains(bodyStr, "login") && !strings.Contains(bodyStr, "unauthorized") {
				ps.AddResult(PentestResult{
					TestName:    "Access Control",
					Severity:    "HIGH",
					Status:      "VULNERABLE",
					Description: "Administrative interface accessible without authentication",
					Evidence:    fmt.Sprintf("Path: %s returned status 200", path),
					Remediation: "Implement proper authentication for administrative interfaces",
				})
			}
		}
		resp.Body.Close()
	}
}

// 5. Encryption Strength Evaluation
func (ps *PentestSuite) EncryptionEvaluation() {
	fmt.Println("\n[+] Starting Encryption Strength Evaluation...")
	
	ps.testCipherSuites()
	ps.testCertificateValidation()
}

// Cipher Suites Testing
func (ps *PentestSuite) testCipherSuites() {
	fmt.Println("[+] Testing Cipher Suites...")
	
	testURL := fmt.Sprintf("https://%s", ps.target)
	
	// Test with different cipher suites
	weakCiphers := []uint16{
		tls.TLS_RSA_WITH_RC4_128_SHA,
		tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
	}
	
	for _, cipher := range weakCiphers {
		tr := &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
				CipherSuites:       []uint16{cipher},
			},
		}
		client := &http.Client{Transport: tr, Timeout: 5 * time.Second}
		
		resp, err := client.Get(testURL)
		if err == nil {
			ps.AddResult(PentestResult{
				TestName:    "Cipher Suites",
				Severity:    "HIGH",
				Status:      "VULNERABLE",
				Description: "Weak cipher suite supported",
				Evidence:    fmt.Sprintf("Cipher suite ID: %d", cipher),
				Remediation: "Disable weak cipher suites and use modern encryption",
			})
			resp.Body.Close()
			return
		}
	}
	
	ps.AddResult(PentestResult{
		TestName:    "Cipher Suites",
		Severity:    "INFO",
		Status:      "SECURE",
		Description: "No weak cipher suites detected",
		Evidence:    "Tested common weak cipher suites",
		Remediation: "Continue using strong cipher suites",
	})
}

// Certificate Validation Testing
func (ps *PentestSuite) testCertificateValidation() {
	fmt.Println("[+] Testing Certificate Validation...")
	
	testURL := fmt.Sprintf("https://%s", ps.target)
	
	// Test with proper certificate validation
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Get(testURL)
	
	if err != nil {
		if strings.Contains(err.Error(), "certificate") {
			ps.AddResult(PentestResult{
				TestName:    "Certificate Validation",
				Severity:    "HIGH",
				Status:      "VULNERABLE",
				Description: "Certificate validation issues",
				Evidence:    err.Error(),
				Remediation: "Fix certificate configuration and validation",
			})
		}
		return
	}
	defer resp.Body.Close()
	
	if resp.TLS != nil && len(resp.TLS.PeerCertificates) > 0 {
		cert := resp.TLS.PeerCertificates[0]
		
		// Check certificate expiration
		if time.Now().After(cert.NotAfter) {
			ps.AddResult(PentestResult{
				TestName:    "Certificate Validation",
				Severity:    "CRITICAL",
				Status:      "EXPIRED",
				Description: "SSL certificate has expired",
				Evidence:    fmt.Sprintf("Expired on: %s", cert.NotAfter),
				Remediation: "Renew SSL certificate immediately",
			})
		} else if time.Now().Add(30 * 24 * time.Hour).After(cert.NotAfter) {
			ps.AddResult(PentestResult{
				TestName:    "Certificate Validation",
				Severity:    "MEDIUM",
				Status:      "EXPIRING",
				Description: "SSL certificate expiring soon",
				Evidence:    fmt.Sprintf("Expires on: %s", cert.NotAfter),
				Remediation: "Plan certificate renewal",
			})
		} else {
			ps.AddResult(PentestResult{
				TestName:    "Certificate Validation",
				Severity:    "INFO",
				Status:      "VALID",
				Description: "SSL certificate is valid",
				Evidence:    fmt.Sprintf("Valid until: %s", cert.NotAfter),
				Remediation: "Continue monitoring certificate expiration",
			})
		}
	}
}

// Generate comprehensive report
func (ps *PentestSuite) GenerateReport() *PentestReport {
	ps.mu.Lock()
	defer ps.mu.Unlock()
	
	summary := TestSummary{TotalTests: len(ps.results)}
	
	for _, result := range ps.results {
		switch result.Severity {
		case "CRITICAL":
			summary.CriticalIssues++
		case "HIGH":
			summary.HighIssues++
		case "MEDIUM":
			summary.MediumIssues++
		case "LOW":
			summary.LowIssues++
		case "INFO":
			summary.InfoIssues++
		}
	}
	
	return &PentestReport{
		StartTime: time.Now().Add(-time.Hour), // Approximate start time
		EndTime:   time.Now(),
		Target:    ps.target,
		Results:   ps.results,
		Summary:   summary,
	}
}

// Print report to console
func (ps *PentestSuite) PrintReport() {
	report := ps.GenerateReport()
	
	fmt.Println("\n" + strings.Repeat("=", 80))
	fmt.Println("                    PENETRATION TEST REPORT")
	fmt.Println(strings.Repeat("=", 80))
	fmt.Printf("Target: %s\n", report.Target)
	fmt.Printf("Start Time: %s\n", report.StartTime.Format("2006-01-02 15:04:05"))
	fmt.Printf("End Time: %s\n", report.EndTime.Format("2006-01-02 15:04:05"))
	fmt.Printf("Duration: %s\n", report.EndTime.Sub(report.StartTime).String())
	fmt.Println(strings.Repeat("-", 80))
	
	fmt.Println("\nEXECUTIVE SUMMARY:")
	fmt.Printf("Total Tests: %d\n", report.Summary.TotalTests)
	fmt.Printf("Critical Issues: %d\n", report.Summary.CriticalIssues)
	fmt.Printf("High Issues: %d\n", report.Summary.HighIssues)
	fmt.Printf("Medium Issues: %d\n", report.Summary.MediumIssues)
	fmt.Printf("Low Issues: %d\n", report.Summary.LowIssues)
	fmt.Printf("Info Issues: %d\n", report.Summary.InfoIssues)
	
	fmt.Println("\nDETAILED FINDINGS:")
	fmt.Println(strings.Repeat("-", 80))
	
	for i, result := range report.Results {
		fmt.Printf("\n[%d] %s\n", i+1, result.TestName)
		fmt.Printf("Severity: %s\n", result.Severity)
		fmt.Printf("Status: %s\n", result.Status)
		fmt.Printf("Description: %s\n", result.Description)
		fmt.Printf("Evidence: %s\n", result.Evidence)
		fmt.Printf("Remediation: %s\n", result.Remediation)
		fmt.Printf("Timestamp: %s\n", result.Timestamp.Format("2006-01-02 15:04:05"))
		fmt.Println(strings.Repeat("-", 40))
	}
	
	fmt.Println("\nRECOMMendations:")
	fmt.Println("1. Address all CRITICAL and HIGH severity issues immediately")
	fmt.Println("2. Implement security monitoring and logging")
	fmt.Println("3. Regular security assessments and penetration testing")
	fmt.Println("4. Security awareness training for development team")
	fmt.Println("5. Implement secure development lifecycle (SDLC)")
	fmt.Println(strings.Repeat("=", 80))
}

// Save report to JSON file
func (ps *PentestSuite) SaveReport(filename string) error {
	report := ps.GenerateReport()
	
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()
	
	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(report)
}

func main() {
	fmt.Println("Penetration Testing Suite v1.0")
	fmt.Println("==============================")
	
	// Get target from command line or use default
	target := "localhost:8080"
	if len(os.Args) > 1 {
		target = os.Args[1]
	}
	
	fmt.Printf("Target: %s\n", target)
	fmt.Print("\nPress Enter to start penetration testing (or Ctrl+C to cancel): ")
	bufio.NewReader(os.Stdin).ReadBytes('\n')
	
	// Create penetration testing suite
	ps := NewPentestSuite(target)
	
	fmt.Println("\n[+] Starting Comprehensive Penetration Test...")
	start := time.Now()
	
	// Execute all test categories
	ps.PortScan()
	ps.WebVulnScan()
	ps.SecurityConfigAnalysis()
	ps.AuthenticationTesting()
	ps.EncryptionEvaluation()
	
	duration := time.Since(start)
	fmt.Printf("\n[+] Penetration testing completed in %s\n", duration)
	
	// Generate and display report
	ps.PrintReport()
	
	// Save report to file
	reportFile := fmt.Sprintf("pentest_report_%s.json", time.Now().Format("20060102_150405"))
	if err := ps.SaveReport(reportFile); err != nil {
		fmt.Printf("Error saving report: %v\n", err)
	} else {
		fmt.Printf("\n[+] Report saved to: %s\n", reportFile)
	}
	
	fmt.Println("\n[+] Penetration testing completed successfully!")
	fmt.Println("[!] Please review all findings and implement recommended security measures.")
}